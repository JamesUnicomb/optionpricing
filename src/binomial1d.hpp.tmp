#ifndef BINOMIAL1D_HPP
#define BINOMIAL1D_HPP

#include <omp.h>

class BinomialMesh1D
{
private:
    const int n;
    double *v;
    double **varr;

public:
    BinomialMesh1D(int n);
    BinomialMesh1D(int n, const double &a);
    double getValue(
        double &p, double &pn);
    double getValue(
        double &p, double &pn, int current_step, int num_up_movements);
    double getExerciseValue(
        int current_step, int num_up_movements);
    void parallelStencilTriangle(
        double *p, double *past_edge_points, int jstart, int m, int triangle_size, int level);
    void parallelStencilRhombus(
        double *p, double *past_edge_points, double *curr_edge_points, int jstart, int m, int width, int level);
    double calculate_serial();
    double calculate_parallel(int numblocks);
    void set_initial_condition();
    void print();
    ~BinomialMesh1D();
};

BinomialMesh1D::BinomialMesh1D(int n) : n(n), v(n > 0 ? new double[n] : nullptr), varr(n > 0 ? new double *[n] : nullptr)
{
    int i;
    if (varr)
    {
        int nel = n * (n + 1) / 2;
        varr[0] = nel > 0 ? new double[nel] : nullptr;
    }

    for (i = 1; i < n; i++)
        varr[i] = varr[i - 1] + i;
}

BinomialMesh1D::BinomialMesh1D(int n, const double &a) : n(n), v(n > 0 ? new double[n] : nullptr), varr(n > 0 ? new double *[n] : nullptr)
{
    int i, j;
    for (i = 0; i < n; i++)
        v[i] = a;

    if (varr)
    {
        int nel = n * (n + 1) / 2;
        varr[0] = nel > 0 ? new double[nel] : nullptr;
    }

    for (i = 1; i < n; i++)
        varr[i] = varr[i - 1] + i;

    for (i = 0; i < n; i++)
        for (j = 0; j <= i; j++)
            varr[i][j] = a;
}

double BinomialMesh1D::getValue(
    double &p, double &pn)
{
    return 0.5 * (p + pn);
}

inline double BinomialMesh1D::getValue(
    double &p, double &pn, int current_step, int num_up_movements)
{
    return 0.5 * (p + pn);
}

inline double BinomialMesh1D::getExerciseValue(
    int current_step, int num_up_movements)
{
    return 0.0;
}

void BinomialMesh1D::parallelStencilTriangle(
    double *p, double *past_edge_points, int jstart, int m, int triangle_size, int level)
{
    int i, j;
    double value;

    for (i = 0; i < triangle_size - 1; i++)
    {
        for (j = 0; j < triangle_size - i - 1; j++)
        {
            value = getValue(p[jstart + j], p[jstart + j + 1]);
            p[jstart + j] = value;
            varr[level - i - 2][jstart + j] = value;

            if (jstart != 0 && j == 0)
            {
                past_edge_points[jstart - m + i + 1] = value;
            }
        }
    }
}

void BinomialMesh1D::parallelStencilRhombus(
    double *p, double *past_edge_points, double *curr_edge_points, int jstart, int m, int width, int level)
{
    int i, j, row_length;
    double value;

    for (i = 0; i < m; i++)
    {
        row_length = std::min(i + 1, width);
        for (j = 0; j < row_length; j++)
        {
            if (j == i)
            {
                value = getValue(
                    p[jstart + (m - i - 1) + j],
                    past_edge_points[jstart + i]);
                p[jstart + (m - i - 1) + j] = value;
                varr[level + (m - i - 1) - 1][jstart + (m - i - 1) + j] = value;
            }
            else
            {
                value = getValue(
                    p[jstart + (m - i - 1) + j],
                    p[jstart + (m - i - 1) + j + 1]);
                p[jstart + (m - i - 1) + j] = value;
                varr[level + (m - i - 1) - 1][jstart + (m - i - 1) + j] = value;

                if (jstart != 0 && i == m - 1 && j == 0)
                {
                    curr_edge_points[jstart - m] = value;
                }
            }
        }
    }
    for (i = 0; i < width - 1; i++)
    {
        row_length = std::min(m - i - 1, width - i - 1);
        for (j = 0; j < row_length; j++)
        {
            value = getValue(
                p[jstart + j],
                p[jstart + j + 1]);
            p[jstart + j] = value;
            varr[level - i - 2][jstart + j] = value;

            if (jstart != 0 && j == 0)
            {
                curr_edge_points[jstart - m + i + 1] = value;
            }
        }
    }
}

double BinomialMesh1D::calculate_serial()
{
    int i, j, rowlen;
    double value;
    for (i = 0; i < n; i++)
    {
        rowlen = n - i - 1;
        for (j = 0; j < rowlen; j++)
        {
            value = getValue(v[j], v[j + 1]);
            v[j] = value;
            varr[n - i - 2][j] = value;
        }
    }

    return v[0];
}

double BinomialMesh1D::calculate_parallel(int numblocks)
{
    int blocksize = n / numblocks;
    int edgeblocksize = n % numblocks;

    double *past_edge_points = new double[n];
    double *curr_edge_points = new double[n];

    for (int i = 0; i < n; i++)
    {
        past_edge_points[i] = curr_edge_points[i] = 0.0;
    }
    for (int i = 0; i < n; i = i + blocksize)
    {
        past_edge_points[i] = v[i + blocksize];
    }

    for (int i = 0; i < numblocks; i++)
    {
        parallelStencilTriangle(
            v,
            past_edge_points,
            i * blocksize,
            blocksize,
            blocksize,
            n);
    }
    if (edgeblocksize > 0)
    {
        parallelStencilTriangle(
            v,
            past_edge_points,
            numblocks * blocksize,
            blocksize,
            edgeblocksize,
            n);
    }

    for (int row = 1; row < numblocks + 1; row++)
    {
        for (int j = 0; j < numblocks - row; j++)
        {
            parallelStencilRhombus(
                v,
                past_edge_points,
                curr_edge_points,
                j * blocksize,
                blocksize,
                blocksize,
                (numblocks - row) * blocksize + edgeblocksize);
        }
        if (edgeblocksize > 0)
        {
            parallelStencilRhombus(
                v,
                past_edge_points,
                curr_edge_points,
                (numblocks - row) * blocksize,
                blocksize,
                edgeblocksize,
                (numblocks - row) * blocksize + edgeblocksize);
        }

        for (int k = 0; k < n; k++)
        {
            past_edge_points[k] = curr_edge_points[k];
        }
    }

    return v[0];
}

void BinomialMesh1D::set_initial_condition()
{
    for (int j = 0; j < n; j++)
    {
        v[j] = (j < n / 2) ? 1.0 : 0.0;
        varr[n - 1][j] = (j < n / 2) ? 1.0 : 0.0;
    }
}

void BinomialMesh1D::print()
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", i);
        for (int j = 0; j <= i; j++)
        {
            printf("%f ", varr[i][j]);
        }
        printf("\n");
    }
}

BinomialMesh1D::~BinomialMesh1D()
{
    if (v != nullptr)
    {
        delete[] (v);
    }
}

#endif